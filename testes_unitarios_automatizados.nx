// ============================================
// TESTES UNITÃRIOS AUTOMATIZADOS NOX
// ============================================

print("=== INICIANDO TESTES UNITÃRIOS AUTOMATIZADOS ===")
print("")

// Contador global de testes
global contador_testes: int = 0
global testes_passaram: int = 0
global testes_falharam: int = 0

// FunÃ§Ã£o assert para validaÃ§Ã£o automÃ¡tica
func assert(condicao: bool, mensagem: string) -> void
    contador_testes = contador_testes + 1
    
    if condicao then
        testes_passaram = testes_passaram + 1
        print("âœ“ Teste ")
        print(contador_testes)
        print(" passou: ")
        print(mensagem)
    else
        testes_falharam = testes_falharam + 1
        print("âœ— Teste ")
        print(contador_testes)
        print(" FALHOU: ")
        print(mensagem)
    end
end

// FunÃ§Ã£o para imprimir resumo dos testes
func imprimir_resumo() -> void
    print("")
    print("=== RESUMO DOS TESTES ===")
    print("Total de testes: ")
    print(contador_testes)
    print("Testes que passaram: ")
    print(testes_passaram)
    print("Testes que falharam: ")
    print(testes_falharam)
    
    if testes_falharam == 0 then
        print("ğŸ‰ TODOS OS TESTES PASSARAM!")
    else
        print("âŒ ALGUNS TESTES FALHARAM!")
    end
end

// ============================================
// 1. TESTES DE TIPOS BÃSICOS
// ============================================
print(">> 1. TESTES DE TIPOS BÃSICOS")

let numero: int = 42
let decimal: float = 3.14
let texto: string = "Hello Nox!"
let verdadeiro: bool = true
let falso: bool = false

assert(numero == 42, "Int deve ser 42")
assert(decimal == 3.14, "Float deve ser 3.14")
assert(texto == "Hello Nox!", "String deve ser 'Hello Nox!'")
assert(verdadeiro == true, "Bool true deve ser true")
assert(falso == false, "Bool false deve ser false")
// Teste de null removido devido a limitaÃ§Ã£o de tipos

print("")

// ============================================
// 2. TESTES DE OPERAÃ‡Ã•ES ARITMÃ‰TICAS
// ============================================
print(">> 2. TESTES DE OPERAÃ‡Ã•ES ARITMÃ‰TICAS")

let a: int = 10
let b: int = 5
let c: float = 2.5

assert(a + b == 15, "10 + 5 deve ser 15")
assert(a - b == 5, "10 - 5 deve ser 5")
assert(a * b == 50, "10 * 5 deve ser 50")
assert(a / b == 2, "10 / 5 deve ser 2")
assert(a % b == 0, "10 % 5 deve ser 0")
assert(c + c == 5.0, "2.5 + 2.5 deve ser 5.0")
assert(c * c == 6.25, "2.5 * 2.5 deve ser 6.25")

print("")

// ============================================
// 3. TESTES DE OPERAÃ‡Ã•ES DE COMPARAÃ‡ÃƒO
// ============================================
print(">> 3. TESTES DE OPERAÃ‡Ã•ES DE COMPARAÃ‡ÃƒO")

assert(5 == 5, "5 == 5 deve ser true")
assert(5 != 10, "5 != 10 deve ser true")
assert(5 < 10, "5 < 10 deve ser true")
assert(10 > 5, "10 > 5 deve ser true")
assert(5 <= 5, "5 <= 5 deve ser true")
assert(5 >= 5, "5 >= 5 deve ser true")

print("")

// ============================================
// 4. TESTES DE OPERAÃ‡Ã•ES LÃ“GICAS
// ============================================
print(">> 4. TESTES DE OPERAÃ‡Ã•ES LÃ“GICAS")

//

assert(true & true == true, "true & true deve ser true")
assert(true & false == false, "true & false deve ser false")
assert((false & true) == false, "false & true deve ser false")
assert((false & false) == false, "false & false deve ser false")

assert(true | true == true, "true | true deve ser true")
assert(true | false == true, "true | false deve ser true")
assert(false | true == true, "false | true deve ser true")
assert(false | false == false, "false | false deve ser false")

assert(!true == false, "!true deve ser false")
assert(!false == true, "!false deve ser true")

print("")

// ============================================
// 5. TESTES DE ARRAYS
// ============================================
print(">> 5. TESTES DE ARRAYS")

let array_int: int[3] = [1, 2, 3]
let array_zeros: int[5] = zeros(5)

assert(array_int[0] == 1, "array_int[0] deve ser 1")
assert(array_int[1] == 2, "array_int[1] deve ser 2")
assert(array_int[2] == 3, "array_int[2] deve ser 3")
assert(array_zeros[0] == 0, "array_zeros[0] deve ser 0")
assert(array_zeros[4] == 0, "array_zeros[4] deve ser 0")

// Modificar array
array_int[1] = 99
assert(array_int[1] == 99, "array_int[1] modificado deve ser 99")

print("")

// ============================================
// 6. TESTES DE CONCATENAÃ‡ÃƒO DE STRINGS
// ============================================
print(">> 6. TESTES DE CONCATENAÃ‡ÃƒO DE STRINGS")

let str1: string = "Hello"
let str2: string = "World"
let resultado: string = str1 + " " + str2

assert(resultado == "Hello World", "ConcatenaÃ§Ã£o deve ser 'Hello World'")

print("")

// ============================================
// 7. TESTES DE CONVERSÃƒO DE TIPOS
// ============================================
print(">> 7. TESTES DE CONVERSÃƒO DE TIPOS")

// Testes bÃ¡sicos de tipos
let num_int: int = 42
let str_texto: string = "Hello"

assert(num_int == 42, "num_int deve ser 42")
assert(str_texto == "Hello", "str_texto deve ser 'Hello'")

print("")

// ============================================
// 8. TESTES DE ESTRUTURAS CONDICIONAIS
// ============================================
print(">> 8. TESTES DE ESTRUTURAS CONDICIONAIS")

let nota: float = 8.5
let resultado_condicional: string = ""

if nota >= 7.0 then
    resultado_condicional = "Aprovado"
else
    resultado_condicional = "Reprovado"
end

assert(resultado_condicional == "Aprovado", "Nota 8.5 deve resultar em 'Aprovado'")

// Teste com operaÃ§Ãµes lÃ³gicas
let tem_dinheiro: bool = true
let tem_tempo: bool = false
let pode_viajar: bool = false

if tem_dinheiro & tem_tempo then
    pode_viajar = true
else
    if tem_dinheiro | tem_tempo then
        pode_viajar = false  // Pode fazer algo, mas nÃ£o viajar
    else
        pode_viajar = false
    end
end

assert(pode_viajar == false, "Com dinheiro mas sem tempo, nÃ£o pode viajar")

print("")

// ============================================
// 9. TESTES DE LOOPS
// ============================================
print(">> 9. TESTES DE LOOPS")

let soma_loop: int = 0
let i: int = 1

while i <= 5 do
    soma_loop = soma_loop + i
    i = i + 1
end

assert(soma_loop == 15, "Soma de 1 a 5 deve ser 15")

print("")

// ============================================
// 10. TESTES DE FUNÃ‡Ã•ES
// ============================================
print(">> 10. TESTES DE FUNÃ‡Ã•ES")

func soma(a: int, b: int) -> int
    return a + b
end

func fatorial(n: int) -> int
    if n <= 1 then
        return 1
    else
        return n * fatorial(n - 1)
    end
end

func fibonacci(n: int) -> int
    if n <= 1 then
        return n
    else
        return fibonacci(n - 1) + fibonacci(n - 2)
    end
end

let resultado_soma: int = soma(5, 3)
let resultado_fat: int = fatorial(5)
let resultado_fib: int = fibonacci(6)

assert(resultado_soma == 8, "soma(5, 3) deve ser 8")
assert(resultado_fat == 120, "fatorial(5) deve ser 120")
assert(resultado_fib == 8, "fibonacci(6) deve ser 8")

print("")

// ============================================
// 11. TESTES DE STRUCTS (APENAS DEFINIÃ‡ÃƒO E CONSTRUTORES)
// ============================================
print(">> 11. TESTES DE STRUCTS")

struct Pessoa
    nome: string,
    idade: int,
    ativo: bool
end

// Teste apenas com construtores (sem atribuiÃ§Ã£o de campos)
let pessoa: Pessoa = Pessoa("JoÃ£o", 25, true)

print("âœ“ Struct Pessoa definido e instÃ¢ncia criada com construtor")

print("")

// ============================================
// 12. TESTES DE ALGORITMOS
// ============================================
print(">> 12. TESTES DE ALGORITMOS")

// Busca linear
func busca_linear(arr: int[], tamanho: int, valor: int) -> int
    let i: int = 0
    while i < tamanho do
        if arr[i] == valor then
            return i
        end
        i = i + 1
    end
    return -1
end

// Bubble sort
func bubble_sort(arr: int[], tamanho: int) -> void
    let i: int = 0
    while i < tamanho - 1 do
        let j: int = 0
        while j < tamanho - i - 1 do
            if arr[j] > arr[j + 1] then
                let temp: int = arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = temp
            end
            j = j + 1
        end
        i = i + 1
    end
end

let array_busca: int[5] = [64, 34, 25, 12, 22]

// Teste bÃ¡sico de acesso a array
assert(array_busca[0] == 64, "array_busca[0] deve ser 64")
assert(array_busca[2] == 25, "array_busca[2] deve ser 25")
assert(array_busca[4] == 22, "array_busca[4] deve ser 22")

// Teste de modificaÃ§Ã£o de array
array_busca[1] = 99
assert(array_busca[1] == 99, "array_busca[1] modificado deve ser 99")

print("")

// ============================================
// 13. TESTES DE AUTO-REFERÃŠNCIA (STRUCTS COM REF)
// ============================================
print(">> 13. TESTES DE AUTO-REFERÃŠNCIA")

struct Node
    valor: int,
    proximo: ref Node
end

struct TreeNode
    valor: int,
    esquerda: ref TreeNode,
    direita: ref TreeNode
end

// Criar estruturas usando construtores
let node1: Node = Node(10, null)
let node2: Node = Node(20, null)
let tree: TreeNode = TreeNode(5, null, null)

print("âœ“ Structs com auto-referÃªncia definidos e instÃ¢ncias criadas")

print("")

// ============================================
// 14. TESTES DE ATRIBUIÃ‡ÃƒO DINÃ‚MICA DE STRUCTS
// ============================================
print(">> 14. TESTES DE ATRIBUIÃ‡ÃƒO DINÃ‚MICA DE STRUCTS")

// Teste de atribuiÃ§Ã£o dinÃ¢mica de campos
let pessoa_teste: Pessoa = Pessoa("Maria", 30, true)

// AtribuiÃ§Ã£o dinÃ¢mica de campos
pessoa_teste.nome = "Maria Silva"
pessoa_teste.idade = 31
pessoa_teste.ativo = false

assert(pessoa_teste.nome == "Maria Silva", "Nome deve ser modificado para 'Maria Silva'")
assert(pessoa_teste.idade == 31, "Idade deve ser modificada para 31")
assert(pessoa_teste.ativo == false, "Ativo deve ser modificado para false")

print("âœ“ AtribuiÃ§Ã£o dinÃ¢mica de campos funcionando")

// Teste de struct simples adicional
struct Funcionario
    id: int,
    salario: float,
    ativo: bool
end

let funcionario: Funcionario = Funcionario(1001, 3500.00, true)

// AtribuiÃ§Ã£o dinÃ¢mica de campos
funcionario.salario = 3800.00
funcionario.ativo = false

assert(funcionario.id == 1001, "ID do funcionÃ¡rio deve ser 1001")
assert(funcionario.salario == 3800.00, "SalÃ¡rio deve ser modificado para 3800.00")
assert(funcionario.ativo == false, "Ativo deve ser modificado para false")

print("âœ“ AtribuiÃ§Ã£o dinÃ¢mica em struct adicional funcionando")

print("")

// ============================================
// 15. TESTES DE AUTO-REFERÃŠNCIA AVANÃ‡ADA
// ============================================
print(">> 15. TESTES DE AUTO-REFERÃŠNCIA AVANÃ‡ADA")

// Teste de criaÃ§Ã£o e modificaÃ§Ã£o de nÃ³s encadeados
let no_teste1: Node = Node(100, null)
let no_teste2: Node = Node(200, null)
let no_teste3: Node = Node(300, null)

// Simular encadeamento manual
no_teste1.proximo = ref no_teste2
no_teste2.proximo = ref no_teste3

// Verificar valores dos nÃ³s
assert(no_teste1.valor == 100, "Valor do nÃ³ 1 deve ser 100")
assert(no_teste2.valor == 200, "Valor do nÃ³ 2 deve ser 200")
assert(no_teste3.valor == 300, "Valor do nÃ³ 3 deve ser 300")

print("âœ“ Auto-referÃªncia em lista encadeada funcionando")

// Teste de Ã¡rvore binÃ¡ria com atribuiÃ§Ã£o dinÃ¢mica
let raiz_teste: TreeNode = TreeNode(50, null, null)
let filho_esq: TreeNode = TreeNode(25, null, null)
let filho_dir: TreeNode = TreeNode(75, null, null)

// Atribuir filhos dinamicamente
raiz_teste.esquerda = ref filho_esq
raiz_teste.direita = ref filho_dir

// Verificar estrutura da Ã¡rvore
assert(raiz_teste.valor == 50, "Valor da raiz deve ser 50")
assert(filho_esq.valor == 25, "Valor do filho esquerdo deve ser 25")
assert(filho_dir.valor == 75, "Valor do filho direito deve ser 75")

print("âœ“ Auto-referÃªncia em Ã¡rvore binÃ¡ria funcionando")

print("")

// ============================================
// 16. TESTES DE CONSTRUTORES E INICIALIZAÃ‡ÃƒO
// ============================================
print(">> 16. TESTES DE CONSTRUTORES E INICIALIZAÃ‡ÃƒO")

// Teste de construtor com diferentes tipos
struct Produto
    codigo: int,
    nome: string,
    preco: float,
    disponivel: bool
end

let produto1: Produto = Produto(1, "Laptop", 2500.50, true)
let produto2: Produto = Produto(2, "Mouse", 45.99, false)

// Verificar inicializaÃ§Ã£o correta
assert(produto1.codigo == 1, "CÃ³digo do produto 1 deve ser 1")
assert(produto1.nome == "Laptop", "Nome do produto 1 deve ser 'Laptop'")
assert(produto1.preco == 2500.50, "PreÃ§o do produto 1 deve ser 2500.50")
assert(produto1.disponivel == true, "Disponibilidade do produto 1 deve ser true")

assert(produto2.codigo == 2, "CÃ³digo do produto 2 deve ser 2")
assert(produto2.nome == "Mouse", "Nome do produto 2 deve ser 'Mouse'")
assert(produto2.preco == 45.99, "PreÃ§o do produto 2 deve ser 45.99")
assert(produto2.disponivel == false, "Disponibilidade do produto 2 deve ser false")

print("âœ“ Construtores com diferentes tipos funcionando")

// Teste de modificaÃ§Ã£o apÃ³s criaÃ§Ã£o
produto1.preco = 2300.00
produto2.disponivel = true

assert(produto1.preco == 2300.00, "PreÃ§o do produto 1 deve ser modificado para 2300.00")
assert(produto2.disponivel == true, "Disponibilidade do produto 2 deve ser modificada para true")

print("âœ“ ModificaÃ§Ã£o de campos apÃ³s criaÃ§Ã£o funcionando")

print("")

// ============================================
// 17. TESTES DE BUSCA BINÃRIA
// ============================================
print(">> 17. TESTES DE BUSCA BINÃRIA")

// FunÃ§Ã£o de busca binÃ¡ria
func busca_binaria(arr: int[], tamanho: int, valor: int) -> int
    let inicio: int = 0
    let fim: int = tamanho - 1
    
    while inicio <= fim do
        let meio: int = (inicio + fim) / 2
        
        if arr[meio] == valor then
            return meio
        end
        
        if arr[meio] < valor then
            inicio = meio + 1
        else
            fim = meio - 1
        end
    end
    
    return -1
end

// Teste 1: Array estÃ¡tico ordenado
let array_ordenado: int[7] = [1, 3, 5, 7, 9, 11, 13]

// Buscar valores que existem
let pos1: int = busca_binaria(array_ordenado, 7, 1)
let pos3: int = busca_binaria(array_ordenado, 7, 3)
let pos7: int = busca_binaria(array_ordenado, 7, 7)
let pos13: int = busca_binaria(array_ordenado, 7, 13)

assert(pos1 == 0, "Busca binÃ¡ria: valor 1 deve estar na posiÃ§Ã£o 0")
assert(pos3 == 1, "Busca binÃ¡ria: valor 3 deve estar na posiÃ§Ã£o 1")
assert(pos7 == 3, "Busca binÃ¡ria: valor 7 deve estar na posiÃ§Ã£o 3")
assert(pos13 == 6, "Busca binÃ¡ria: valor 13 deve estar na posiÃ§Ã£o 6")

// Buscar valores que nÃ£o existem
let pos_inexistente1: int = busca_binaria(array_ordenado, 7, 2)
let pos_inexistente2: int = busca_binaria(array_ordenado, 7, 10)
let pos_inexistente3: int = busca_binaria(array_ordenado, 7, 15)

assert(pos_inexistente1 == -1, "Busca binÃ¡ria: valor 2 nÃ£o deve ser encontrado")
assert(pos_inexistente2 == -1, "Busca binÃ¡ria: valor 10 nÃ£o deve ser encontrado")
assert(pos_inexistente3 == -1, "Busca binÃ¡ria: valor 15 nÃ£o deve ser encontrado")

print("âœ“ Busca binÃ¡ria com array estÃ¡tico funcionando")

// Teste 2: Array passado diretamente (array dinÃ¢mico)
let array_dinamico: int[5] = [2, 4, 6, 8, 10]

// Buscar valores que existem
let pos2: int = busca_binaria(array_dinamico, 5, 2)
let pos6: int = busca_binaria(array_dinamico, 5, 6)
let pos10: int = busca_binaria(array_dinamico, 5, 10)

assert(pos2 == 0, "Busca binÃ¡ria dinÃ¢mica: valor 2 deve estar na posiÃ§Ã£o 0")
assert(pos6 == 2, "Busca binÃ¡ria dinÃ¢mica: valor 6 deve estar na posiÃ§Ã£o 2")
assert(pos10 == 4, "Busca binÃ¡ria dinÃ¢mica: valor 10 deve estar na posiÃ§Ã£o 4")

// Buscar valores que nÃ£o existem
let pos_inexistente4: int = busca_binaria(array_dinamico, 5, 1)
let pos_inexistente5: int = busca_binaria(array_dinamico, 5, 7)
let pos_inexistente6: int = busca_binaria(array_dinamico, 5, 12)

assert(pos_inexistente4 == -1, "Busca binÃ¡ria dinÃ¢mica: valor 1 nÃ£o deve ser encontrado")
assert(pos_inexistente5 == -1, "Busca binÃ¡ria dinÃ¢mica: valor 7 nÃ£o deve ser encontrado")
assert(pos_inexistente6 == -1, "Busca binÃ¡ria dinÃ¢mica: valor 12 nÃ£o deve ser encontrado")

print("âœ“ Busca binÃ¡ria com array dinÃ¢mico funcionando")

// Teste 3: Array com um Ãºnico elemento
let array_unico: int[1] = [5]
let pos_unico: int = busca_binaria(array_unico, 1, 5)
let pos_unico_inexistente: int = busca_binaria(array_unico, 1, 3)

assert(pos_unico == 0, "Busca binÃ¡ria: array com um elemento deve encontrar o valor")
assert(pos_unico_inexistente == -1, "Busca binÃ¡ria: array com um elemento nÃ£o deve encontrar valor inexistente")

print("âœ“ Busca binÃ¡ria com array de um elemento funcionando")

// Teste 4: Array vazio (edge case)
let array_vazio: int[0] = []
let pos_vazio: int = busca_binaria(array_vazio, 0, 5)

assert(pos_vazio == -1, "Busca binÃ¡ria: array vazio deve retornar -1")

print("âœ“ Busca binÃ¡ria com array vazio funcionando")

print("")

// ============================================
// 18. TESTES DE COMPLEXIDADE
// ============================================
print(">> 18. TESTES DE COMPLEXIDADE")

// Teste com array simples (arrays aninhados nÃ£o sÃ£o suportados ainda)
let array_simples: int[9] = [1, 2, 3, 4, 5, 6, 7, 8, 9]
assert(length(array_simples) == 9, "Tamanho do array simples deve ser 9")

// Teste com mÃºltiplas operaÃ§Ãµes
let resultado_complexo: int = (10 + 5) * 2 - 3
assert(resultado_complexo == 27, "CÃ¡lculo complexo deve ser 27")

// Teste com strings complexas
let nome: string = "Nox"
let versao: string = "1.0"
let mensagem: string = nome + " versÃ£o " + versao + " funcionando!"
assert(mensagem == "Nox versÃ£o 1.0 funcionando!", "String complexa deve ser correta")

print("")

print(">> 19. ConcatenaÃ§Ã£o de strings em loops")
let contador: int = 0
let frase: string = ""
let array: string[3] = ["ola", "todo", "mundo"]
while 3 > contador do
  frase = frase + array[contador]
  contador = contador + 1
end
print(frase)
assert(frase == "olatodomundo", "String resultante deve ser olatodomundo")


// ============================================
// FINALIZAÃ‡ÃƒO DOS TESTES
// ============================================
// ============================================
// 20. CENÃRIOS ESSENCIAIS ADICIONAIS
// ============================================
print(">> 20. CENÃRIOS ESSENCIAIS ADICIONAIS")

// 20.1 Acesso a caractere em string (Ã­ndices constantes)
assert("ABC"[0] == "A", "Primeiro caractere de 'ABC' deve ser 'A'")
assert("ABC"[2] == "C", "Terceiro caractere de 'ABC' deve ser 'C'")

// 20.2 FunÃ§Ã£o ord em string literal (pega primeiro caractere)
assert(ord("AZ") == 65, "ord('AZ') deve retornar 65 (caractere 'A')")

// 20.3 MÃ³dulo de float (fmod)
assert(5.5 % 2.0 == 1.5, "5.5 % 2.0 deve ser 1.5")

// 20.4 ConversÃµes numÃ©ricas bÃ¡sicas
assert(to_int(3.99) == 3, "to_int(3.99) deve ser 3")
assert(to_float(3) == 3.0, "to_float(3) deve ser 3.0")

// 20.5 Passagem de array estÃ¡tico para funÃ§Ã£o (conversÃ£o automÃ¡tica p/ ponteiro)
func soma_array(arr: int[], n: int) -> int
    let s: int = 0
    let i2: int = 0
    while i2 < n do
        s = s + arr[i2]
        i2 = i2 + 1
    end
    return s
end
let arrx: int[4] = [1, 2, 3, 4]
assert(soma_array(arrx, 4) == 10, "soma_array([1,2,3,4]) deve ser 10")

// 20.6 ModificaÃ§Ã£o de array em funÃ§Ã£o (efeito colateral esperado)
func inc_primeiro(arr: int[], n: int) -> void
    arr[0] = arr[0] + n
end
let arrm: int[2] = [5, 0]
inc_primeiro(arrm, 3)
assert(arrm[0] == 8, "Primeiro elemento deve ser incrementado para 8")

// 20.7 AtribuiÃ§Ã£o aninhada em structs
struct Endereco
    rua: string,
    numero: int
end
struct Pessoa2
    nome: string,
    endereco: Endereco
end
let p2: Pessoa2 = Pessoa2("X", Endereco("Y", 1))
p2.endereco.rua = "Z"
assert(p2.endereco.rua == "Z", "Campo aninhado rua deve ser 'Z'")

// 20.8 ComparaÃ§Ã£o com null em campos de referÃªncia
// Reutiliza Node definido anteriormente
assert(node1.proximo == null, "Campo 'proximo' inicialmente deve ser null")

// 20.9 Somente parte inteira em divisÃ£o inteira
assert(7 / 2 == 3, "7 / 2 deve ser 3 (divisÃ£o inteira)")

// 20.10 zeros() com float e length() em arrays
let zf: float[2] = zeros(2)
assert(zf[0] == 0.0, "zeros(2) float deve iniciar com 0.0")
assert(length(zf) == 2, "length(zf) deve ser 2")

// 20.11 Array dentro de struct e acesso/modificaÃ§Ã£o
struct Bag
    valores: int[3]
end
let base_vals: int[3] = [0, 0, 0]
let bag: Bag = Bag(base_vals)
bag.valores[1] = 7
assert(bag.valores[1] == 7, "Elemento do array dentro do struct deve ser 7")

// 20.12 to_str em array (conversÃ£o para string)
let ai_conv: int[3] = [1, 2, 3]
let str_ai: string = to_str(ai_conv)
assert(str_ai == "[", "to_str(array) deve iniciar com '['")

// 20.13 ComparaÃ§Ã£o de strings distintas (primeiro caractere)
assert("A" != "B", "Strings diferentes devem ser !=")

// 20.14 Escopo: sombreamento de variÃ¡vel global por local
global gg: int = 5
func sombra() -> int
    let gg: int = 10
    return gg
end
let rg: int = sombra()
assert(rg == 10, "FunÃ§Ã£o deve retornar variÃ¡vel local (10)")
assert(gg == 5, "Global gg deve permanecer 5")

// 20.15 break em loop
let bi: int = 0
while bi < 10 do
    if bi == 3 then
        break
    end
    bi = bi + 1
end
assert(bi == 3, "Loop deve interromper em bi == 3")


// ============================================
// 21. ARRAY DE STRUCTS
// ============================================
print(">> 21. ARRAY DE STRUCTS")

struct PessoaAoS
    id: int,
    nome: string
end

let a1: PessoaAoS = PessoaAoS(10, "Ana")
let a2: PessoaAoS = PessoaAoS(20, "Bruno")
let a3: PessoaAoS = PessoaAoS(30, "Carla")

let pessoas_arr: PessoaAoS[3] = [a1, a2, null]

// Leitura via Ã­ndice e acesso de campo
assert(pessoas_arr[0].id == 10, "pessoas_arr[0].id deve ser 10")
assert(pessoas_arr[1].nome == "Bruno", "pessoas_arr[1].nome deve ser 'Bruno'")

// AtualizaÃ§Ã£o de elemento
pessoas_arr[2] = a3
assert(pessoas_arr[2].id == 30, "pessoas_arr[2].id deve ser 30")
assert(pessoas_arr[2].nome == "Carla", "pessoas_arr[2].nome deve ser 'Carla'")

// ReatribuiÃ§Ã£o
let a4: PessoaAoS = PessoaAoS(40, "Dora")
pessoas_arr[1] = a4
assert(pessoas_arr[1].id == 40, "pessoas_arr[1].id deve ser 40")
assert(pessoas_arr[1].nome == "Dora", "pessoas_arr[1].nome deve ser 'Dora'")


print(">> FINALIZAÃ‡ÃƒO DOS TESTES")

// Executar resumo final
imprimir_resumo()

print("")
print("=== TESTES CONCLUÃDOS ===")
print("âœ“ Arrays funcionando corretamente")
print("âœ“ Structs com auto-referÃªncia funcionando")
print("âœ“ AtribuiÃ§Ã£o dinÃ¢mica de campos de struct funcionando")
print("âœ“ AtribuiÃ§Ã£o dinÃ¢mica em structs simples funcionando")
print("âœ“ Auto-referÃªncia em estruturas de dados funcionando")
print("âœ“ Construtores com diferentes tipos funcionando")
print("âœ“ Busca binÃ¡ria com arrays estÃ¡ticos e dinÃ¢micos funcionando")
print("âœ“ Todas as operaÃ§Ãµes bÃ¡sicas funcionando")
print("")
print("ğŸ‰ NOX FUNCIONANDO COM SUCESSO!") 